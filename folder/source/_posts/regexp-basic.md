---
title: regexp-basic
date: 2016/01/08 15:49
tags: javascript
categories: 前端基础
---

## 我对正则表达式的一点理解

前几日拜读jquery源码，发现里边有大量的正则表达式，看着着实头疼，今天特地研究了一下，自己稍微沉淀了一点东西。  

#### 1. 何为正则表达式？
    
    通常情况下，我们所看到的正则表达式就是一串难懂的字符串（如：\[\\w!#$%&'*+/=?^_`{|}~-\]+(?:\\.\[\\w!#$%&'*+/=?^_`{|}~-\]+)*@(?:\[\\w\](?:\[\\w-\]*\[\\w\])?\\.)+\[\\w\](?:\[\\w-\]*\[\\w\])?），没错，正则表达式就是符合某一类规则的一串表达式。
<!-- more -->
#### 2. 什么情况下会用到正则表达式？
    
    通常我们会在字符串的查找匹配，替换中使用到正则。
    
#### 3. 如何使用正则表达式？
    
    前面也说过，正则表达式需要符合一定的规则，也就是说，按规则来书写，就基本可以满足需求，当然，只是满足基本，在实际应用中还应该考虑各种情况，这就需要添加更多的限定条件。我们先拿前面提到的正则式来举个例子。
    
    \[\\w!#$%&'*+/=?^_`{|}~-\]+(?:\\.\[\\w!#$%&'*+/=?^_`{|}~-\]+)*@(?:\[\\w\](?:\[\\w-\]*\[\\w\])?\\.)+\[\\w\](?:\[\\w-\]*\[\\w\])?
    
    看着这么一大串乱七八糟的字符有没有很头疼呢，我们且不说这是干什么用的，先根据附录中的规则分解剖析一番，把这个表达式分几部分
    

1.  \[\\w!#$%&'*+/=?^_`{|}~-\]+ 
    
    中括号\[\]里面是我们要匹配的字符，后面的+是重复至少一次的意思，\\w是指此字符串以下划线、数字或字母打头，或者以!#$%&'*+/=?^_`{|}~-中的任何一个打头，!#$%&'*+/=?^_`{|}~-这么一大串其实就是我们键盘顶部那些字符。
    
2.  (?:\\.\[\\w!#$%&'*+/=?^_`{|}~-\]+)* 
    
    这一串紧跟着首字符之后，小括号()里面是一个子表达式，用来分组的，(?:\\.)见附录表4中的捕获，.是匹配除换行符以外的任意字符，而\\.是转义之后的，单纯指.，.后必须跟字符或字符串。最后面的*指重复0次或更多次的意思，小括号里面还a中出现的\[\\w!#$%&'*+/=?^_`{|}~-\]+。
    
3.  @
    
    这个就是匹配单纯的@符号，必须出现的。
    
4.  (?:\[\\w\](?:\[\\w-\]*\[\\w\])?\\.)+ 
    
    字符或字符串以.结束，内部还嵌套了一个子表达式(?:\[\\w-\]*\[\\w\])?，不难理解。
    
5.  \[\\w\](?:\[\\w-\]*\[\\w\])? 
    
    d内部嵌套的子表达式一样。
    

看完上面的解释，你一定也看出这个正则表达式的功能了吧，不错，正是用来匹配邮箱的。当然，上面匹配的比较严格，我们也可以简单的使用\[\\w+~!#$%^&*()_+\]+@\\w+.\\w+进行匹配，依项目需要了。看到这里，有没有觉得其实正则表达式并没有想象中那么可怕呢。下面我们来写一个简单的匹配电话号码的正则式（如：010-11111111,0101111111等）：

^\[0\]\\d{2}-?\\d{8}|\\\[0\]d{3}-?\\d{7,8}$

写完之后，可以在线（[http://tool.oschina.net/regex/](http://tool.oschina.net/regex/)）测试一下我们所写的正则式是否符合要求，

#### 4. 附录：

表1. 常用元字符

语法 | 说明
---- | ----
. | 匹配除换行符以外的任意字符
\w | 匹配字母或数字或下划线
\s | 匹配任意的空白符
\d | 匹配数字
\b | 匹配单词的开始或结束
^ | 匹配字符串的开始
$ | 匹配字符串的结束

表2.常用的限定符

语法 | 说明
---- | ----
* | 重复零次或更多次
+ | 重复一次或更多次
? | 重复零次或一次
{n} | 重复n次
{n,} | 重复n次或更多次
{n,m} | 重复n到m次

表3.常用的反义代码

语法 | 说明
---- | ----
\W | 匹配任意不是字母，数字，下划线的字符
\S | 匹配任意不是空白符的字符
\D | 匹配任意非数字的字符
\B | 匹配不是单词开头或结束的位置
[^x] | 匹配除了x以外的任意字符
[^aeiou] | 匹配除了aeiou这几个字母以外的任意字符

表4.常用分组语法

语法 | 说明
---- | ----
捕获：(exp) | 匹配exp,并捕获文本到自动命名的组里
捕获：(?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
捕获：(?:exp) | 匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言：(?=exp) | 匹配exp前面的位置
零宽断言：(?<=exp) | 匹配exp后面的位置
零宽断言：(?!exp) | 匹配后面跟的不是exp的位置
零宽断言：(?<!exp) | 匹配前面不是exp的位置
注释：(?#comment) | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

表5.懒惰限定符

语法 | 说明
---- | ----
*? | 重复任意次，但尽可能少重复
+? | 重复1次或更多次，但尽可能少重复
?? | 重复0次或1次，但尽可能少重复
{n,m}? | 重复n到m次，但尽可能少重复
{n,}? | 重复n次以上，但尽可能少重复

表6.常用的处理选项

语法 | 说明
---- | ----
IgnoreCase(忽略大小写) | 匹配时不区分大小写。
Multiline(多行模式) | 
更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式) | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。
IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。
ExplicitCapture(显式捕获) | 仅捕获已被显式命名的组。

表7.尚未详细讨论的语法

语法 | 说明
---- | ----
\a | 报警字符(打印它的效果是电脑嘀一声)
\b | 通常是单词分界位置，但如果在字符类里使用代表退格
\t | 制表符，Tab
\r | 回车
\v | 竖向制表符
\f | 换页符
\n | 换行符
\e | Escape
\0nn | ASCII代码中八进制代码为nn的字符
\xnn | ASCII代码中十六进制代码为nn的字符
\unnnn | Unicode代码中十六进制代码为nnnn的字符
\cN | ASCII控制字符。比如\cC代表Ctrl+C
\A | 字符串开头(类似^，但不受处理多行选项的影响)
\Z | 字符串结尾或行尾(不受处理多行选项的影响)
\z | 字符串结尾(类似$，但不受处理多行选项的影响)
\G | 当前搜索的开头
\p{name} | Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp) | 贪婪子表达式
(?<x>-<y>exp) | 平衡组
(?im-nsx:exp) | 在子表达式exp中改变处理选项
(?im-nsx) | 为表达式后面的部分改变处理选项
(?(exp)yes\|no) | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes) | 同上，只是使用空表达式作为no
(?(name)yes\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
(?(name)yes) | 同上，只是使用空表达式作为no

##### [转自] [我对正则表达式的一点理解](https://my.oschina.net/luweiweiwei/blog/599739)